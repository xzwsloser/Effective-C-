# 确定对象被使用之前已经被初始化
- 注意创建对象的时候,比如简单的数据类型或者自定以类型,可以交给默认构造函数进行初始化,但是不一定保证对象被初始化
- 明确初始化和赋值的区别:
  - 初始化: 对于自定义数据类型表示利用构造函数创建对象
  - 赋值: 表示调用赋值运算符号,对于对象进行赋值
## 使用初始化列表为成员属性赋值
- 如果不利用初始化列表赋值,那么成员函数的创建分为如下步骤: 利用构造函数初始化,调用赋值运算符号赋值
- 如果利用初始化列表初始化,就是直接调用构造函数进行初始化

- 使用注意时向:
  - 在初始化列表中列出所有成员变量
  - 如果成员被`const`修饰,或者是一个引用(引用的值不可以改变)就不可以使用赋值初始化,推荐初始化列表
## non-local static变量
- 表示非局部的`static`修饰的变量
- `static`关键字: https://blog.csdn.net/m0_46208463/article/details/140628413(作用)
- 对于不同模块中的全局`static`变量,由于初始化顺序不一样,所以一定需要注意在一个模块的某一个类中利用另外一个模块中的某一个类中的全局`static`变量的时候,由于初始化顺序不确定就会导致出错
- 所以对于这一种情况的解决方式就是使用`local-static`变量,并且这一个变量的获取方式使用引用获取,就是定义返回`local static`引用的函数,利用引用获取,比如:
```cpp
// 定义函数
class FileSystem{
    FileSystem& tfs()
    {
        static FileSystem tfs;  // 全局变量区,限定作用域
        return tfs; 
    }
};
// 使用方式(另外的模块中)
Directory::Directory()
{
    std::size_t disks = tfs().numDisks();
}

```
## 总结
- 对于内置数据类型进行手动初始化,应为`c++`中不保证可以初始化他们
- 构造函数最好使用出是哈u列表,列表列出的成员变量,顺序和他们在`class`中声明的顺序一致
- 为了免除"跨编译单元初始化次序"问题,需要使用`local static`对象替代`non-local static`对象