# 在资源管理类中小心使用copying行为
- 有时候我们的需求可能不再是简单的在函数调用结束之后删除对应的指针,而是在对象初始化或者被删除的时候进行相应的操作,比如文件描述符的关闭或者互斥锁的开锁和加锁等操作,所以这就会导致我们需要自定义一个`RAII`对象来帮助我们管理资源,比如如下就是一个利用 `RAII` 对象管理互斥锁资源的代码:
```cpp
class Lock{
public:
    Lock(Mutex* m) : mutex_ptr(m){
        lock(mutex_ptr);
    }

    ~Lock(){
        unlock(mutex_ptr);  // 自己写的析构函数也会自动释放资源
    }
private:
    Mutex* mutex_ptr;
};
```
- 但是如果发生了复制行为的话,由于默认的拷贝构造函数或者复制运算符号执行的都是浅拷贝,所以新创建的对象中的指针还是指向了原来对象的指针指向的空间,这很明显不合适(容易造成内存重复释放等问题)
- 所以对于`RAII`对象,解决方式如下:
  - 禁止复制,最简单的一种方法,这一种方法的实现可以参看之前条款`06`,创建一个父类,这一个父类中定义私有的拷贝构造函数和赋值运算符
  - 对于底层采用引用技术法: `std::shared_ptr`的底层就是使用的引用计数法,但是这一种引用计数法只是针对于对象的释放操作而非加锁和释放锁的操作,但是智能指针的底层提供了删除器,在这一个删除器中就可以指定需要进行的操作,实现代码如下(使用智能指针代替原始指针)(删除器可以使用可调用对象指示):
```cpp
class Lock{
public:
    Lock(Mutex* mutex): mutex_ptr(mutex , unlock) {
        lock(mutex_ptr);
    }
private:
    std::shared_ptr<Mutex> mutex_ptr;
};
```
 - 复制底层资源: 也就是对于指针对象进行深拷贝
 - 转移底层资源的拥有权利,也就是每一次只有一个`RAII`对象可以管理资源,比如可以使用`unique_ptr`对象进行资源的管理
- 总结:
  - 复制`RAII`对象必须一并复制它所管理的资源,所以资源的拷贝行为决定了`RAII`对象的拷贝行为
  - 普遍常见的`RAII`对象的拷贝行为可以是: 禁止拷贝,使用引用计数法,复制底层资源,转移资源(`std::move`)等

