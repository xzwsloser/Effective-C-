# 让接口被正确使用,不易被误用
- `C++`中的"接口"指的就是: 函数的签名或者`class`的可访问元素
1. 第一种接口难以使用的情况,比如如下代码中的构造方法:
```cpp
class Date{
public:
    Date(int mouth , int day , int year) {}
};
```
- 对于这一个构造日期的函数,很容易使得我们传入的参数的顺序发生错误,那么应该如何避免这一种情况呢?  -- 可以使用自定的类型来表示这些结构,比如可以导入新的类型比如:
```cpp
struct Day{
    Day(int d): val(d) {}
    int val;
}
```
- 这一种方式就很好的规定了用户传入的信息的规则,但是又会引发另外的问题(对于日期月份这些固定的东西,需要传入正确的值),解决方法一种就是利用枚举(但是枚举有时候会被当成`int`使用),另外一种方式就是利用返回`local static`的成员函数代替,比如:
```cpp
class Month{
public:
    static Month Jan() {return Month(1)};
    static Month Feb() {return Month(2)};
    ...
    static Month Dec() {return Month(12)};
    Month(int val): val(val) {};
private:
    int val;
};
```
- 返回一个`local static`的作用就是之前提到过的`non-static`变量的初始化顺序不固定
2. 第二种接口容易被误用的情况就是: 一致性差,比如`STL`容器中,每一个容器都有一个`size`方法可以返回大小,这就比较好,用户不用记住各个容器的差别,但是`Java`中,数组使用`length`,字符串使用`length()`,集合使用`size()`,这一种不一致性就会导致用户容易误用(至少我是这样的)
3. 第三种接口容易被误用的情况就是: 任何接口如果要求用户必须记得做某一件事情,那么就是有这"不正确使用"的倾向,比如之前的一个`create_ptr`函数,返回一个原始指针,就容易让用户忘记释放指针,所以这个情况的解决方式就是利用智能指针比如`shared_ptr`
4. 还是上一种情况,如果设计一个接口,可以让用户把接口的返回值(可能是一个指针)传递给另外一个函数处理,而不是自己处理就会导致使用错误的资源解析机制的问题(可能忘记`delete`了),所以解决方式就是把需要调用的函数作为`shared_ptr`的删除器函数(注意定义方式和`unique_ptr`不同)
```cpp
shared_ptr<Person>sp(new Person() , [](Person* p) {delete p;});

unique_ptr<Person , function<void(Person*)>>up(new Person() , [](Person* p){delete p;});
```
- 最后补充一点使用`shared_ptr`的好处,对于那些在一个动态库中创建在另外一个动态库中释放的变量,会引发潜在的客户端错误,但是`shared_ptr`的删除器可以追溯到它的创建时期,也就是说删除器和创建时机是绑定的,不会发生这样的错误,使用智能指针可以显著的降低用户错误
- 总结:
  - 好的接口容易被正确使用,不容易被误用,需要在所有接口中努力达到这些性质
  - "促进正确使用"的办法包括接口的一致性,以及与内置类型的行为兼容
  - "阻止误用"的办法包含建立新的类型,限制对于类型的操作(比如利用`const`修饰返回值),以及与内置类型的行为兼容
  - `shared_ptr`支持定制型删除器,可以防范`DLL`问题,可以被用来自动解除互斥锁等