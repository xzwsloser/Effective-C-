# 透彻了解 inlining 的里里外外
- `inline`函数被后观念就是: 将"对此函数的每一个调用"都以函数本体替换之,所以如果频繁使用`inlining`会造成程序的体积比较大(对于可用空间而言)
- 但是系统底层会对于`inline`函数进行优化,所以最后生成的代码一定小于你写的代码
- 注意`inline`函数只是对于编译器的一个申请,而不是一个强制命令,这一项申请可以是隐喻申请或者明确提出，隐喻申请的方法就是把函数定义在`class`中:
```cpp
class Person {
public:
    int age() const {return theAge};
private:
    int theAge;
};
```
- 这样的函数通常是成员函数,但是定义在类中的`friend`函数也可以被隐喻声明为`inline`

- 明确`inline`的做法即使直接声明为`inline`:
```cpp
template<typename T>
inline const T& std::max(const T& a , const T& b);
```
- 注意`template`的具象化和`inlining`无关,如果你正在写一个模板,而认为你所有根据这一个模板生成的函数都应该被`inlined`,那么就直接声明为`inline`即可,如果没有理由把模板的实现声明成`inline`就不要加上`inline`

- 大部分编译器拒绝将比较复杂的函数(比如循环,递归)的函数声明为`inlining`,而对于所有的`virtual`函数的调用也会使得`inlining`落空,这是由于`virtual`让你直到运行才知道调用哪一个函数(一个函数是否被`inline`取决于编译器)

- 虽然编译器有时愿意给某一个函数`inline`,但是如果程序要取得某一个`inline`函数的地址,那么编译器通常为这一个函数生成一个`outlined`函数本体

- 通常情况下,编译器不会对于使用函数指针调用的函数实施`inline`,比如:
```cpp
inline void f() {...}
void (*pf)() = f;
f();  // inline
pf(); // 不会 inline
```
- 另外尽量不要把构造函数或者析构函数声明为`inline`,这是由于构造函数或者析构底层生成的代码可能比较复杂,比如对于一个类,默认构造函数中需要调用各个成员的构造方法,对于有继承关系的类还需要调用父类的构造方法

- `inline`函数的缺点如下:
  - 如果改变`inline`函数需要重新编译,但是改变普通函数只用重新连接即可
  - 大部分调试器对于`inline`函数都手足无策(相当于这一个函数不存在只是代码块)
- 所以我们在决定那些函数可以被声明为`inline`的时候,不要一开始就把任何函数声明为`inline`,至少把范围限定在一定成为`inline`函数的身上
- 注意`80-20`的经验法则: 平均而言一个程序把`80%`的执行时间放在`20%`的代码上面,所以我们需要做的就是找到 并且优化哪一个`20%`的代码

- 总结:
  - 将大多数`inlining`限制在小型,被频繁调用的函数身上,这可以使得日后的条是过程和二进制升级更加容易,也可以使得潜在的代码膨胀问题最小化,使得程序的速度提升最大化
  - 不要只是因为`function template`出现在头文件,就把他们声明为`inline`
